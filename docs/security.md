# Server Security & SSL Setup

This document describes the multi-layered security approach used to protect the home server and ensure secure HTTPS connections.

## Security Layers Overview

1.  **System Firewall**: Only essential ports are open (SSH, HTTP, HTTPS, Syncing).
2.  **Cloudflare Proxying**: All public web traffic is proxied through Cloudflare to hide the server's real IP.
3.  **Origin Cloaking (Nginx)**: Nginx is configured to only accept public web traffic from Cloudflare's official IP ranges. Direct hits to the public IP are rejected.
4.  **Fail2Ban**: Automatically bans IPs that exhibit malicious behavior (brute-forcing SSH, scanning for vulnerabilities, or bypassing Cloudflare).
5.  **SSL/TLS**: All connections are encrypted using Let's Encrypt (public) or a private CA (internal).

---

## 1. Certificate (Let's Encrypt)

To enable ssh on our public domain, we use a certificate generated by **ACME (Let's Encrypt)** with the **DNS-01 challenge** via Cloudflare. This allows us to obtain certificates without opening port 80/443 on the router for the challenge itself.

### 1. Cloudflare API Configuration
1.  **Transfer DNS**: Point your domain nameservers to Cloudflare.
2.  **API Token**: Create a token at `My Profile > API Tokens > Create Token`.
    *   Template: `Edit zone DNS`
    *   Permissions: `Zone - DNS - Edit`
    *   Zone Resources: `Include - Specific zone - yourdomain.com`

### 2. Secrets Management
To keep the Cloudflare API token secure and out of the Git history, we manage it manually on the server.

1.  **Initialize the secret**:
    Run the generation script on your server:
    ```bash
    sudo ./scripts/generate-acme-secrets
    ```
2.  **Follow the prompt**:
    The script will ask for your Cloudflare API token and save it to `/var/lib/secrets/acme/cloudflare_token`.

### 3. Verification
Check the status of the certificate generation:
```bash
systemctl status acme-yourdomain.com.service
journalctl -u acme-yourdomain.com.service -f
```
---

## 2. Cloudflare & Nginx Integration (Public Domain)

To prevent attackers from bypassing Cloudflare and hitting your server directly, we implement **Origin Cloaking**.

### How it works
- **Real IP Support**: Nginx is configured to trust Cloudflare's IP ranges. It extracts the visitor's real IP from the `CF-Connecting-IP` header so that logs reflect the actual visitor.
- **Access Control**: The public VirtualHost only allows traffic from Cloudflare IPs and your local LAN. All other direct traffic receives a `403 Forbidden`.
- **Automatic Banning**: Fail2Ban monitors Nginx logs for these `403` errors. If an IP tries to hit your public domain directly (bypassing the proxy), it is permanently banned at the system firewall level.

### Configuration
Managed in `modules/services/nginx.nix` and `modules/services/cloudflare-ips.nix`.

---

## 3. Internal SSL (.local Domains)

Standard Certificate Authorities (like Let's Encrypt) cannot issue certificates for `.local` domains. We use `mkcert` to act as our own private Certificate Authority.

### 1. Prerequisites
Ensure `mkcert` is installed on your local management machine.

### 2. Generate the Local Root CA
Run once on your **local machine**:
```bash
mkcert -install
```
This creates a Root CA and installs it into your system's trust store.

### 3. Generate Certificates for HOSTNAME
Generate a certificate covering all subdomains:
```bash
mkcert "*.hostname.local" hostname.local 127.0.0.1 ::1
```

### 4. Deploying the Certificates
Copy the files from your local machine to the server:
```bash
scp _wildcard.hostname.local+3.pem server:/var/lib/secrets/certs/hostname.crt
scp _wildcard.hostname.local+3-key.pem server:/var/lib/secrets/certs/hostname.key
```

### 5. NixOS Configuration
Modules like `nginx.nix` are configured to look for certificates in `/var/lib/secrets/certs`.

> [!IMPORTANT]
> Because these paths are outside the Git repository, you must use the `--impure` flag when rebuilding:
> `sudo nixos-rebuild switch --impure --flake .#HOSTNAME`

---

## 4. Troubleshooting & Maintenance

### Checking Expiration
```bash
openssl x509 -enddate -noout -in /var/lib/secrets/certs/hostname.crt
```

### Reloading Configuration
If you update certificates or Nginx settings:
```bash
sudo systemctl reload nginx
```
